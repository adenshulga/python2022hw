Я намеренно не создавал папки, чтобы туда сюда не переходить по файлам во время проверки.

# Дз 1

1) git система контроля версий. Github - сервер для хранения версий
2) Коллаборация разработчиков. Разграничение прав, чтобы условный сеньор мог только вносить коммиты в main ветку
3) Коммит, ветка, версии
4) Чтобы одна ветка содержала работающую конкретно сейчас версию кода, другая ветка, допустим переписывать легаси код, 3я ветка
для разработки следующей версии
5) merge по дате добавления, rebase ветка "поверх другой" засовывается
6) централизованная - версии хранятся на сервере
децентрализованная - версии хранятся на нескольких компьютерах

# Дз 2
Копипаст моего конспекта с семинаров :)
1)Процедурное программирование - код сплошный полотном
Функциональное - когда есть повторяющиеся действия, загнать их в функции. Данные хранили раньше все равно в переменных.
Не было разделения к каким переменным можно вызывать функции, к каким нельзя
ООП - Есть обьект, внутри есть данные и способы их обработки.

2) разделение интерфейса(public) и реализации(private)(работа с обьектом только через методы внутри объекта)
Все что создаем будет делиться на закрытые и скрытые обьекты
Скрытие можно обойти и соответственно есть договоренности по поводу пометки скрытых обьектов

3) локальная переменная имеющая отношение к своему экземпляру класса называется либо полем, либо атрибутом 
локальная функция имеющая отношение к своему экземпляру класса называется методом

4) Инициалиазия - перед использованием задаем нужные значения полей класса или их модификация. 
Конструктор - выделяет память под новый обьект и инициализирует поля класса(присваивает значения полям, чтобы все могло работать). Питон сам за нас распоряжается памятью и сам создает деструктор(на каждый new, есть delete :), за счет сборщика мусора, нам не надо париться про области видимости.

# Дз 3
1) Насколько помню, классовая переменная, это общая переменная для всех обьектов класса

2) утиная типизация - ходит как утка, крякает как утка - то это утка
потому не нужна перегрузка в питоне(и ее там нету)

3) Переопределением функции, если у нас перегрузка работает во время компиляции, и компилятор сам линкует нужные функции к нужным аргументам, то в питоне у нас на ходу функция не менятся

4) Это разные методы, нужно для того чтобы операция суммы была симметричной и работала с обьектами для которых суммирование с нашим обьектом не определено

# Дз 4
1) Дочерний класс наследует поля и методы родительского класса
2) super говорит подставить класс предка
super смотрит есть ли в старшем классе собственное переопределение
если нет идет во второй и ищет в нем
если хотим постарше взять метод из super, то
передаем аргументом в super название класса
3) Хотим бить по рукам пользователю, чтобы не было UB. Ну и чтобы в рантайме программа не ложилась. Но! Совать исключения всегда и везде некорректно, так как замедляется работа программы
4) Нужно создать класс, унаследованный от Exception

# дз 5
1) for не метод, но используется, __iter__
2) должен быть определен метод __iter__
3) Генератор создает элементы на ходу
4) yield

# дз 6
1) Питон это не всегда делает за нас, по идее последствия UB, но как пример, содержимое может поменяться
2) Это скрытый блок try-except-finally. Это способ уменьшить количество повторяющегося кода
3) Нужна для сохранения различных структур данных в файл
4) pickle.load(file) может десериализовать объекты со сложным состоянием, если работать с методами __getstate__ и __setstate__

# дз 7
1) Импортирует ВСЕ классы в наше пространство имен, соответственно проблема в том что может легко возмикнуть конфликт имен
2) Самое последнее
3) Декоратор медленный
4) Только на скорость

# дз 8
1) Ограничены количеством ядер процессора
2) Опа опа, concurrency зашел в чат. С распараллеливанием большая проблема - это некоторая синхронизация действий, иначе все будет записываться в рандомном порядке
3) Сильно зависит от алгоритма, который пытаемся реализовать. А вообще универсального ответа нет, пример: переодическая ротация RISC и CISC архитектур процессоров. Умнейшие люди все еще спорят!!!
4) Можно вызвать параллельно одну и ту же функцию, но с разными аргументами.






